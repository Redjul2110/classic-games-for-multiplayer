import { cleanupAndExit } from './games.js';

const RED = 'red';   // Player (Bottom)
const WHITE = 'white'; // AI (Top)
const KING = 'king';

export class Checkers {
    constructor(container, mode = 'local', session = null, currentUser = null) {
        this.container = container;
        this.mode = mode;
        this.session = session;
        this.currentUser = currentUser;
        this.board = []; // 8x8
        this.turn = RED;
        this.selectedPiece = null; // {r, c}
        this.validMoves = []; // Array of {r, c}

        // Determine side
        if (this.mode === 'online') {
            const isHost = this.session.host_id === this.currentUser.id;
            this.mySide = isHost ? RED : WHITE;
        } else {
            this.mySide = RED;
        }

        this.initGame();
        if (this.mode === 'online') this.initRealtime();
    }

    initRealtime() {
        import('./supabase-client.js').then(({ onlineGamesClient }) => {
            this.channel = onlineGamesClient.channel(`game:${this.session.id}`);
            this.channel.on('broadcast', { event: 'move' }, ({ payload }) => {
                // Opponent moved
                const { from, to } = payload;
                this.selectedPiece = from; // Spoof selection
                this.validMoves = [to]; // Force move
                this.executeMove(to.r, to.c, false); // false = don't broadcast back
            })
                .subscribe();
        });
    }

    initGame() {
        // Initialize 8x8 Board
        for (let r = 0; r < 8; r++) {
            const row = [];
            for (let c = 0; c < 8; c++) {
                if ((r + c) % 2 === 1) { // Dark squares only
                    if (r < 3) row.push({ color: WHITE, type: 'man' });
                    else if (r > 4) row.push({ color: RED, type: 'man' });
                    else row.push(null);
                } else {
                    row.push(null); // Unusable square
                }
            }
            this.board.push(row);
        }

        this.renderUI();
    }

    renderUI() {
        this.container.innerHTML = `
            <div class="glass-panel" style="max-width: 500px; margin: 0 auto; text-align: center;">
                <h2 style="margin-bottom: 20px;">Checkers</h2>
                <div style="display: flex; justify-content: space-between; margin-bottom: 20px; font-size: 1.1rem;">
                    <span id="game-info" style="color: var(--text-secondary);">
                        ${this.mode === 'online' ? (this.mySide === RED ? "You are Red" : "You are White") : "Local Game"}
                    </span>
                    <span id="game-status" style="font-weight: bold;">Red's Turn</span>
                    <button id="exit-btn" class="btn btn-ghost" style="padding: 5px 10px; font-size: 0.8rem;">Exit</button>
                </div>
                
                <div id="checkers-board" style="
                    display: grid; 
                    grid-template-columns: repeat(8, 1fr); 
                    width: 100%; 
                    aspect-ratio: 1; 
                    border: 2px solid var(--border-color);
                    transform: ${this.mode === 'online' && this.mySide === WHITE ? 'rotate(180deg)' : 'none'};
                ">
                    <!-- Grid generated by JS -->
                </div>
            </div>
        `;

        this.updateBoard();
        this.updateStatus();

        this.container.querySelector('#exit-btn').addEventListener('click', () => {
            if (this.mode === 'online') cleanupAndExit(this.session, this.currentUser);
            else location.reload();
        });
    }

    updateBoard() {
        const boardEl = this.container.querySelector('#checkers-board');
        boardEl.innerHTML = '';

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const cell = document.createElement('div');
                const isDark = (r + c) % 2 === 1;

                cell.style.backgroundColor = isDark ? '#222' : '#eee';
                cell.style.display = 'flex';
                cell.style.alignItems = 'center';
                cell.style.justifyContent = 'center';
                cell.dataset.r = r;
                cell.dataset.c = c;

                // Flip pieces visual for White player
                if (this.mode === 'online' && this.mySide === WHITE) {
                    cell.style.transform = 'rotate(180deg)';
                }

                // Highlight valid moves
                if (this.isValidMove(r, c)) {
                    cell.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
                    cell.style.cursor = 'pointer';
                    cell.onclick = () => this.executeMove(r, c, true);
                }

                const piece = this.board[r][c];
                if (piece) {
                    const pieceEl = document.createElement('div');
                    pieceEl.style.width = '70%';
                    pieceEl.style.height = '70%';
                    pieceEl.style.borderRadius = '50%';
                    pieceEl.style.backgroundColor = piece.color === RED ? 'var(--accent-red)' : '#fff';
                    pieceEl.style.boxShadow = '0 0 5px black';
                    pieceEl.style.border = piece.type === KING ? '3px solid gold' : 'none';

                    // Interaction Logic
                    const isMyTurn = this.turn === this.mySide;
                    const isMyPiece = piece.color === this.mySide;
                    const canInteact = (this.mode === 'local' && piece.color === this.turn) || (this.mode === 'online' && isMyTurn && isMyPiece);

                    if (canInteact) {
                        pieceEl.style.cursor = 'pointer';
                        pieceEl.onclick = (e) => {
                            e.stopPropagation(); // Don't trigger cell click
                            this.selectPiece(r, c);
                        };
                    }

                    if (this.selectedPiece && this.selectedPiece.r === r && this.selectedPiece.c === c) {
                        pieceEl.style.boxShadow = '0 0 10px 2px yellow';
                    }

                    cell.appendChild(pieceEl);
                }

                boardEl.appendChild(cell);
            }
        }
    }

    selectPiece(r, c) {
        if (this.board[r][c].color !== this.turn) return;

        // Online: Enforce side
        if (this.mode === 'online' && this.board[r][c].color !== this.mySide) return;

        this.selectedPiece = { r, c };
        this.validMoves = this.calculateMoves(r, c, this.board[r][c]);
        this.updateBoard();
    }

    isValidMove(r, c) {
        return this.validMoves.some(m => m.r === r && m.c === c);
    }

    calculateMoves(r, c, piece) {
        let moves = [];
        const directions = piece.type === KING ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
            piece.color === RED ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]; // Red moves Up (-r), White moves Down (+r)

        directions.forEach(dir => {
            const nr = r + dir[0];
            const nc = c + dir[1];

            if (this.onBoard(nr, nc)) {
                // Regular Move
                if (!this.board[nr][nc]) {
                    moves.push({ r: nr, c: nc, type: 'move' });
                }
                // Capture
                else if (this.board[nr][nc].color !== piece.color) {
                    const jr = nr + dir[0] * 2;
                    const jc = nc + dir[1] * 2;
                    if (this.onBoard(jr, jc) && !this.board[jr][jc]) {
                        moves.push({ r: jr, c: jc, type: 'capture', captured: { r: nr, c: nc } });
                    }
                }
            }
        });
        return moves;
    }

    onBoard(r, c) {
        return r >= 0 && r < 8 && c >= 0 && c < 8;
    }

    executeMove(targetR, targetC, shouldBroadcast = true) {
        const move = this.validMoves.find(m => m.r === targetR && m.c === targetC);
        if (!move) return;

        // Broadcast
        if (shouldBroadcast && this.mode === 'online') {
            this.channel.send({
                type: 'broadcast',
                event: 'move',
                payload: {
                    from: this.selectedPiece,
                    to: { r: targetR, c: targetC, type: move.type, captured: move.captured }
                }
            });
        }

        // Move piece
        const piece = this.board[this.selectedPiece.r][this.selectedPiece.c];
        this.board[targetR][targetC] = piece;
        this.board[this.selectedPiece.r][this.selectedPiece.c] = null;

        // Capture logic
        if (move.type === 'capture') {
            this.board[move.captured.r][move.captured.c] = null;
        }

        // King promotion
        if (piece.color === RED && targetR === 0) piece.type = KING;
        if (piece.color === WHITE && targetR === 7) piece.type = KING;

        // Reset selection
        this.selectedPiece = null;
        this.validMoves = [];

        // Switch turn
        this.turn = this.turn === RED ? WHITE : RED;

        this.updateBoard();
        this.updateStatus();

        if (this.mode === 'local' && this.turn === WHITE) {
            setTimeout(() => this.makeAIMove(), 700);
        }
    }

    updateStatus() {
        const el = this.container.querySelector('#game-status');
        const isMyTurn = this.turn === this.mySide;

        let text = "";
        if (this.mode === 'local') {
            text = this.turn === RED ? "Your Turn" : "AI Turn";
        } else {
            text = isMyTurn ? "Your Turn" : "Opponent Turn";
        }

        el.textContent = text + ` (${this.turn === RED ? "Red" : "White"})`;
        el.style.color = this.turn === RED ? 'var(--accent-red)' : 'white';
    }

    // --- Simple AI ---
    makeAIMove() {
        // Collect all valid moves for WHITE
        let allMoves = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const piece = this.board[r][c];
                if (piece && piece.color === WHITE) {
                    const moves = this.calculateMoves(r, c, piece);
                    moves.forEach(m => allMoves.push({ from: { r, c }, to: m }));
                }
            }
        }

        if (allMoves.length === 0) return; // No moves

        // Prioritize Captures
        const captures = allMoves.filter(m => m.to.type === 'capture');
        const finalMove = captures.length > 0 ? captures[Math.floor(Math.random() * captures.length)] :
            allMoves[Math.floor(Math.random() * allMoves.length)];

        // Execute
        this.selectedPiece = finalMove.from;
        this.validMoves = [finalMove.to];
        this.executeMove(finalMove.to.r, finalMove.to.c, true); // Local AI is technically 'broadcasting' to local state
    }
}
